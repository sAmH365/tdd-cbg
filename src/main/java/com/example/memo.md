# Chap08
## 그 외 테스트가 어려운 코드
1. 메스드 중간에 소켓 통신 코드 포함
    * 소켓 통신이나 HTTP통신은 실제를 대체할 서버를 로컬에 띄워서 처리하는 방법도 존재
2. 콘솔에서 입력 받거나 결과를 콘솔에 출력
3. 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final이다. 이 경우 대역으로 대체가 어려울 수 있다
4. 테스트 대상의 소스를 소유하고 있지 않아 수정이 어렵다

## 테스트 가능한 설계로 바꾸려면
* 의존하는 코드를 대체할 수단 마련
  * 하드 코딩된 상수를 생성자나 메서드 파라미터로 받기
  * 의존 대상을 주입 받기
  * 테스트하고 싶은 코드를 분리하기(`PointRuleTest`)
  * 생성이나 임의 값 생성 기능 분리하기(`DailyBatchLoader`)
  * 외부 라이브러리는 직접 사용하지 말고 감싸서 사용하기(`AuthSservice` ,`LoginService`)
    * 외부라이브러리를 감쌌기 때문에 AuthSservice를 대역으로 교체하고, 인증 성공 상황과 실패 상황에 대해 LoginService가 올바르게 동작하는지 검증하는 테스트 코드 작성 가능
    * 의존하는 대상이 Final클래스거나 의존 대상의 호출 메서드가 final이어서 대역으로 재정의 할 수 없는 경우도 동일한 기법 적용


## 기타
* 테스트 코드에서 데이터 읽을 때 사용하는 파일은 리포지토리에 같이 push하기
  * src/test/file  or  src/test/resources 폴더가 테스트 용도 파일 저장하기 적당함


# Chap09
## WireMock을 이용한 REST 클라이언트 테스트
* 통합테스트가 어려운 대상은 외부서버
  * WireMock을 사용하면 서버 API를 스텁으로 대체 가능
## 스프링 부트의 내장 서버를 이용한 API 기능 테스트
* 스프링 부트의 내장 톰캣을 이용한 방법
  * TestRestTemplate: 스프링 부트가 테스트 목적으로 제공하는 것으로 내장 서버에 연결하는 RestTemplate
