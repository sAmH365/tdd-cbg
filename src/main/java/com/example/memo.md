# Chap08
## 그 외 테스트가 어려운 코드
1. 메스드 중간에 소켓 통신 코드 포함
    * 소켓 통신이나 HTTP통신은 실제를 대체할 서버를 로컬에 띄워서 처리하는 방법도 존재
2. 콘솔에서 입력 받거나 결과를 콘솔에 출력
3. 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final이다. 이 경우 대역으로 대체가 어려울 수 있다
4. 테스트 대상의 소스를 소유하고 있지 않아 수정이 어렵다

## 테스트 가능한 설계로 바꾸려면
* 의존하는 코드를 대체할 수단 마련
  * 하드 코딩된 상수를 생성자나 메서드 파라미터로 받기
  * 의존 대상을 주입 받기
  * 테스트하고 싶은 코드를 분리하기(`PointRuleTest`)
  * 생성이나 임의 값 생성 기능 분리하기(`DailyBatchLoader`)
  * 외부 라이브러리는 직접 사용하지 말고 감싸서 사용하기(`AuthSservice` ,`LoginService`)
    * 외부라이브러리를 감쌌기 때문에 AuthSservice를 대역으로 교체하고, 인증 성공 상황과 실패 상황에 대해 LoginService가 올바르게 동작하는지 검증하는 테스트 코드 작성 가능
    * 의존하는 대상이 Final클래스거나 의존 대상의 호출 메서드가 final이어서 대역으로 재정의 할 수 없는 경우도 동일한 기법 적용


## 기타
* 테스트 코드에서 데이터 읽을 때 사용하는 파일은 리포지토리에 같이 push하기
  * src/test/file  or  src/test/resources 폴더가 테스트 용도 파일 저장하기 적당함


# Chap09
## WireMock을 이용한 REST 클라이언트 테스트
* 통합테스트가 어려운 대상은 외부서버
  * WireMock을 사용하면 서버 API를 스텁으로 대체 가능
## 스프링 부트의 내장 서버를 이용한 API 기능 테스트
* 스프링 부트의 내장 톰캣을 이용한 방법
  * TestRestTemplate: 스프링 부트가 테스트 목적으로 제공하는 것으로 내장 서버에 연결하는 RestTemplate

# Chap10
## 통합 테스트의 상황 설정을 위한 보조 클래스 사용하기
* Helper 클래스들
## 실행 환경이 다르다고 실패하지 않기
* 로컬에서는 성공하는데 빌드 서버에서는 실패한다던가, 윈도우에서는 성공하는데 mac os에서는 실패하는 식의 테스트는 안된다
  * 파일경로가 전형적인 예 ("D\\\mywork\\temp\\bulk.txt") <- 맥에서는 아예 실패, 윈도우도 D드라이브 없으면 실패
  * 상대경로 사용하기
  * OS가 제공하는 임시폴더 사용
## 랜덤하게 실패하지 않기
* 실행 시점에 따라 테스트가 실패하는 또 다른 예
  * 숫자 야구게임의 경우, 정답이 랜덤하게 만들어져서 어떤 숫자를 넣어야 일치하는지 미리 알 수 없음(코드 구조 변경 필요)
  * 직접 랜덤 값을 생성하지 말고 생성자를 통해 값을 받도록 수정하면 테스트가 가능 or 랜덤 값 생성을 다른 객체에 위임하게 수정
## 단위 테스트를 위한 객체 생성 보조 클래스
* 상황 구성을 위해 필요한 데이터가 다소 복ㅈ잡할 때, 테스트를 위한 객체 생성 클래스를 따로 만들기
  * 테스트 코드에서 필요한 객체를 생성할 때 사용할 수 있는 팩토리 클래스들.
  * 요구사항 ex
    * 설문이 공개 상태
    * 설문 조사 기간이 끝나지 않음
    * 설문 객관식 문항이 두 개임
    * 각 객관식 문항의 보기가 두개임
  * 요구사항에 부합하는 테스트 생성 객체를 따로 두기
## 조건부로 검증하지 않기
* 테스트는 성공하거나 실패해야 하고, 테스트가 성공하거나 실패하려면 반드시 단언을 실행해야한다
* 조건에따라 단언을 하지 않으면 이 테스트는 성공하지도 실패하지도 않은 테스트가 된다
  * 단언을 실행하지 않으면 성공한 테스트처럼 보인다(실패해야 하는 테스트인데 눈속임)
  * 조건식을 앞에서 먼저 단언 후에 검사할 코드를 단언
    ```java
    assertTrue(tr.contains("cat"));
    assertEquals("고양이", tr.translate("cat"));
    ```
## 통함 테스트는 필요하지 않은 범위까지 연동하지 않기
* dao테스트를 위해 SpringBootTest 어노테이션을사용하면 모든 스프링 빈들이 올라오기 때문에 시간이 오래걸림 -> 테스트를 실행 안시키고 넘어갈 확률높음
  * DataSource등 DB연동과 관련된 설정만 초기화 하는 어노테이션 사용
  * 설정관련코드를 테스트 코드에서 직접 생성하면 스프링 초기화 과정에서 빠지므로 테스트 시간 더욱 단축
## 더 이상 쓸모 없는 테스트 코드
* LocalDateTime을 문자열로 변환하는코드가 필요한데 사용법을 모를때, 테스트 코드를 사용해서 LocalDateTime의 포맷팅 방법을 익힐 수도 있다.
  * 사용법을 익히고 나면 필요 없어진다
  * 소프트웨어가 제공할 기능을 검증하는 코드도 아니다
  * 테스트 코드는 유지보수의 대상인데 이 코드를 유지해서 얻을 수 있는 이점도 없다
* 단순 테스트 커버리지를 높이기 위한 목적으로 작성한 테스트 코드도 유지할 필요가 없다
  * 변수에 접근하는 get()메서드는 매우 단순해서 테스트를 검증할 필요조차 없다 -> 단순히 커버리지 높이기 위한 용도는 사용하지 말기
  * 테스트 커버리지를 높여야 한다면, 실제로 테스트 코드가 다루지 않는 if-else나 하위 타입 등을 찾아 테스트 추가해야한다
