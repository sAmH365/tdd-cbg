# Chap08
## 그 외 테스트가 어려운 코드
1. 메스드 중간에 소켓 통신 코드 포함
    * 소켓 통신이나 HTTP통신은 실제를 대체할 서버를 로컬에 띄워서 처리하는 방법도 존재
2. 콘솔에서 입력 받거나 결과를 콘솔에 출력
3. 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final이다. 이 경우 대역으로 대체가 어려울 수 있다
4. 테스트 대상의 소스를 소유하고 있지 않아 수정이 어렵다

## 테스트 가능한 설계로 바꾸려면
* 의존하는 코드를 대체할 수단 마련
  * 하드 코딩된 상수를 생성자나 메서드 파라미터로 받기
  * 의존 대상을 주입 받기
  * 테스트하고 싶은 코드를 분리하기(`PointRuleTest`)
  * 생성이나 임의 값 생성 기능 분리하기(`DailyBatchLoader`)
  * 외부 라이브러리는 직접 사용하지 말고 감싸서 사용하기(`AuthSservice` ,`LoginService`)
    * 외부라이브러리를 감쌌기 때문에 AuthSservice를 대역으로 교체하고, 인증 성공 상황과 실패 상황에 대해 LoginService가 올바르게 동작하는지 검증하는 테스트 코드 작성 가능
    * 의존하는 대상이 Final클래스거나 의존 대상의 호출 메서드가 final이어서 대역으로 재정의 할 수 없는 경우도 동일한 기법 적용


## 기타
* 테스트 코드에서 데이터 읽을 때 사용하는 파일은 리포지토리에 같이 push하기
  * src/test/file  or  src/test/resources 폴더가 테스트 용도 파일 저장하기 적당함


# Chap09
## WireMock을 이용한 REST 클라이언트 테스트
* 통합테스트가 어려운 대상은 외부서버
  * WireMock을 사용하면 서버 API를 스텁으로 대체 가능
## 스프링 부트의 내장 서버를 이용한 API 기능 테스트
* 스프링 부트의 내장 톰캣을 이용한 방법
  * TestRestTemplate: 스프링 부트가 테스트 목적으로 제공하는 것으로 내장 서버에 연결하는 RestTemplate

# Chap10
## 통합 테스트의 상황 설정을 위한 보조 클래스 사용하기
* Helper 클래스들
## 실행 환경이 다르다고 실패하지 않기
* 로컬에서는 성공하는데 빌드 서버에서는 실패한다던가, 윈도우에서는 성공하는데 mac os에서는 실패하는 식의 테스트는 안된다
  * 파일경로가 전형적인 예 ("D\\\mywork\\temp\\bulk.txt") <- 맥에서는 아예 실패, 윈도우도 D드라이브 없으면 실패
  * 상대경로 사용하기
  * OS가 제공하는 임시폴더 사용
## 랜덤하게 실패하지 않기
* 실행 시점에 따라 테스트가 실패하는 또 다른 예
  * 숫자 야구게임의 경우, 정답이 랜덤하게 만들어져서 어떤 숫자를 넣어야 일치하는지 미리 알 수 없음(코드 구조 변경 필요)
  * 직접 랜덤 값을 생성하지 말고 생성자를 통해 값을 받도록 수정하면 테스트가 가능 or 랜덤 값 생성을 다른 객체에 위임하게 수정
## 단위 테스트를 위한 객체 생성 보조 클래스
* 상황 구성을 위해 필요한 데이터가 다소 복ㅈ잡할 때, 테스트를 위한 객체 생성 클래스를 따로 만들기
  * 테스트 코드에서 필요한 객체를 생성할 때 사용할 수 있는 팩토리 클래스들.
  * 요구사항 ex
    * 설문이 공개 상태
    * 설문 조사 기간이 끝나지 않음
    * 설문 객관식 문항이 두 개임
    * 각 객관식 문항의 보기가 두개임
  * 요구사항에 부합하는 테스트 생성 객체를 따로 두기
